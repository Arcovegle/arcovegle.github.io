[{"title":"RCTF 2022 Reverse Writeup","date":"2022-12-14T13:09:33.000Z","url":"/2022/12/14/RCTF%202022%20Reverse%20Writeup/","tags":[["reverse","/tags/reverse/"],["writeup","/tags/writeup/"]],"categories":[[" ",""]],"content":" Preface CheckYourKey recover string decrypt web_run huowang solve maze bruteforce picStore checkserver RTTT rdefender Preface2023 年 XCTF 联赛第一站，虽然是在家打的比赛，氛围不如在战队实验室，但和队友远程协作也使得逆向的过程没有那么孤独。48 小时的比赛，逆向部分 7 道题目，有些强队在距离比赛结束还有 15 小时前就 AK 了，而我在比赛结束前 3 小时才终于提交了最后一道 rdefender。 反思了一下，除了 M1 Mac 上调试 x86_64 小有不便之外，根本原因还是对 lua 以及 rust 相关逆向不太熟悉，导致比较多的时间都消耗在了试错上。除了语言特性的因素，如果在逆向过程中可以快速识别出关键结构体，也会大大加快解题的速度，而以上两个问题都需要有相关的经验做基础，需要在平时多积累、多分析。 此外，huowang 这道题目中包含 unicorn 模拟执行的部分，虽然在实际解题过程中并没有涉及，但在以后的学习中有必要专门研究一下，以免出现将来在比赛过程中现学的窘境。 CheckYourKey和今年祥云杯 GetTheCorrectKey 使用了相同的 trick，即数据在 .init_array 中做了预处理解密，主要考察的是 native so 加载的过程 需要注意的是，native 函数 ooxx 在实际调用过程中并非调用 Java_com_ctf_CheckYourKey_MainActivity_ooxx ，而是调用的 sub_8965 ，后者是在 JNI_OnLoad 时通过 Register_Natives 函数指定的 加密算法的识别部分并不困难，根据特征值及比对字符串格式不难最终确认出加密为 AES-ECB + base58 + 换表 base64 recover string decrypt web_run一道简单的 webassembly 逆向，由于看主逻辑的 wat 没有很复杂，便没有借助反编译工具进行分析，而是选择直接看 wat + Chrome 动态调试，分析后程序逻辑如下： 程序一共接收两次输入，第一次要求输出对应的时间戳，第二次要求输入 ca_value func10 接收第一个输入，并在转换后与硬编码 202211110054 进行比较，如果相等则输出 This is one of the best &amp;&amp; happy moments for me. I won&#39;t let you pass! 随后退出 func9 根据转换后的时间戳生成一个 uuid 格式的字符串存入内存中，该字符串即为后续比对的 ca_value 之后程序读入第二个输入即 ca_value，与 func9 生成的 uuid 格式字符串比对，正确则输出 right value,But the time is not the time I want to hide\\ngo ahead!! 由于输入正确的时间戳反而程序会退出，无法生成该时间戳对应的 ca_value，因此思路是 patch wasm 对应逻辑，使得输入正确时间戳 2022&#x2F;11&#x2F;11 00:54 后可以正常继续运行，并在调用 func9 后从内存中 dump 出对应的 ca_value huowang程序有两个校验，第一个是 unicorn 模拟执行相关的，第二个可以明显看出是迷宫 由于输入即为迷宫路径，可以直接 dfs 出迷宫的所有可行路径输入回程序进行爆破 solve maze bruteforce 和出题人反馈了有一个多解后，加了最短路径的 hint，问题不大 picStorelua 5.3.3 的逆向，加载 .bin 文件字节码执行 unluac 恢复 lua 源码失败，观察 .bin 文件头部发现与正常并不相同，逆向分析可执行文件并与 lua 源码进行对比可以发现程序改动了源码中对应 lundump.c 的部分，将 LoadByte [sub_48180], LoadInt [sub_481D0], LoadNumber [sub_48110], LoadInteger [sub_480A0] 四个函数中增加了取反操作，于是可以写脚本还原，队友 immortal 在这里是用 hook 做的，我觉得相当优雅。之后就可以正常通过 unluac 等其他工具还原出 lua 源码了，版本对应即可 lua 的源码并不难懂，主要的逻辑就是将输入字节序列逐个运算后，作为 index 从硬编码数组中取值，随后传入 a_AHy3JniQH4 函数进行验证，而该函数是在可执行文件中通过 lua_setglobal 与 lua_pushcclosure 提前注册的，实际调用的是 check_result_23_impl ，z3 求解即可 其实逆向部分的工作就到此为止，但是在比赛过程中，我也耗费了不小的经历在逆向程序的交互逻辑上，即 bmp 的 upload、download 等操作，对于本题来说也许是多此一举，但对比赛中同名的 pwn 题也许能有所帮助，仅供参考 checkserver程序本身是一个运行在本地 8080 端口的 http 服务，通过提交 POST 请求传参给 authcookie 进行验证 通过交叉引用字符串 [SUCCESS] Auth Success 可以定位到函数 sub_404530 为 check 逻辑所在，分析了一下这里有异常处理的反调试，不过并不影响静态分析。进一步可以定位到 sub_402040 为加密函数，且本质为异或加密，因此可以考虑在 402355 处下断点 dump 出异或的数据 由于处理请求的时候会 fork 子进程，比赛的时候还不知道子进程要怎么调试，卡了一会，但后来队友 immortal 说可以直接 set rip 进行调试，于是得解 RTTTrust 逆向，无符号表，硬看的话会有不小阻碍，于是考虑编写一个 demo 结合 bindiff 恢复一下部分符号表 恢复后 IDA 分析，源 rust 代码的 main 函数对应 std::rt::lang_start_internal 函数的第一个参数，即 sub_EBF0 。分析该函数首先可以注意到的就是函数内有明显的数组逐字节硬编码赋值，随后跟着一个 while(1) 的循环，循环体前面做的实际上是 rust 对于迭代器的边界检查与切片取值，关键的运算就是最后一句语句的异或操作，两段类似操作分别可以得到字符串 Welc0me to RCTF 2O22 与 Congratulations 逆向 sub_E310 可以根据算法结构识别出来是 RC4 加密，结合动态调试可知加密使用的 key 即为前面异或得到的两个字符串中的前者，同时也可以发现，传入 RC4 加密的明文是输入经过某种置换 shuffle 后得到的，并在加密后与同样是硬编码赋值的数组进行比对 通过 strings 里可以看出 rust 源程序使用了 rand_core-0.6.4 这个库，结合静态分析定位到 sub_14FB0 函数是一个 LCG 线性同余生成，根据特征值识别出是伪随机生成相关算法，因此推测 sub_FFB0 为伪随机数生成函数，seed 为 0xDEADBEEF 于是程序的逻辑也明朗了起来，首先将输入根据生成的伪随机数序列进行 shuffle，随后 RC4 加密后与硬编码数组比对，正确则输出 Congratulations 由于 seed 为定值，在调用 RC4 函数处下断点比对原始输入与此时参数即可得知 shuffle 的映射关系，进一步可解密得到 flag rdefender同样是 rust 逆向，不过给了符号表，是很有意思的一道题目，直接说逆向后的结论 有两个关键的结构体，程序限制二者最多有 16 个，其中一个在这里称作 string_struct ，大小为 0x30，另外一个称作 check_struct ，大小为 0x20，二者结构如下 关于交互，每次 while 循环开始首先读入 8 字节，输入的第一字节是模式，0 为读入一个 string_struct，2 为读入一个 check_struct，1 为进入 check 流程 关于数据的读入，程序封装了一个 get_data 函数，首先读入 4 字节 dword 作为数据长度，随后读入对应长度的数据 关于读入 string_struct 流程，首先读入的 8 字节中，第 1 字节为 \\x00 ，随后 7 个字节通过 from_utf8_lossy 转换为字符串作为结构体的 name，在此之后调用 get_data 读取结构体的 string 并将构造好的结构体 push 到 string_struct 的 verctor 中 关于读入 check_struct 流程，首先读入的 8 字节中，第 1 字节为 \\x02 ，随后 1 字节为 check_mode，最后 6 字节为固定的 \\xd1\\x66\\x9c\\x89\\xf3\\x5b ，在此之后调用 get_data 读取结构体的 data 并将构造好的结构体 push 到 check_struct 的 verctor 中 关于 check 流程，读入的 8 字节中，第 1 字节为 \\x01 ，随后 2 字节，分别为 string_struct 与 check_struct 的下标，该流程也有相应的 3 种模式的 check_mode，check_mode 是读入 check_struct 时根据输入指定的 check_mode 0: 将 string_struct 中 string 做以 0x83 为基的进制转换，结果与 check_struct 中 data (4 byte) 对应的 dword 比对 check_mode 1: 检查 check_struct 中 data (1 byte) 是否出现在 string_struct 的 string 中 check_mode 2: 将 check_struct 中 data 作为 vm 指令，与 string_struct 中 string 一同作为参数传入 check 函数执行 关于 check 函数中的虚拟机，是一个较为简单的基于栈与寄存器的 vm 实现，逆向起来并不困难，不再在这里赘述 关于程序输出，主要关注 check 流程中的输出即可，有 \\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00 与 \\x02\\x00\\x00\\x00\\x00\\x00\\x00\\x00 两种输出，对应不同的 check 结果 flag 是在函数开始从文件中读入的，并存入了下标为 0 的 string_struct 中，其 name 为 flag，因此，基于上面逆向分析的结果，可以根据 check 返回值侧信道探测出 flag 字符串内容 "},{"title":"MOSEC 2022 Record","date":"2022-12-04T15:43:56.000Z","url":"/2022/12/04/MOSEC%202022%20Record/","tags":[["record","/tags/record/"],["meeting","/tags/meeting/"]],"categories":[[" ",""]],"content":" Preface Understanding the Apple IO80211Family Subsystem Vol. 2 La La Land: Theory and Practice on Large-Scale Static Bug Hunting for Android Systems MediAttack - break the boot chain of MediaTek SoC Understanding Mach IPC The Tour of Coverage Guided Fuzz for An IoT Micro Kernel System Feat(My First EV)!: Add Support for App Store Epilogue Preface这篇文章在参会结束后就已经被我提上日程了，一直拖到现在才正式开始写。已然是 12 月，刚好距离会议一个月整。写这篇参会回忆的目的也很简单，一方面是沉淀会议给我带来的启发与思考，另一方面则是一种激励。 今年的 MOSEC 是 11 月 4 日在上海万达瑞华酒店举办的，酒店坐落于上海外滩，与陆家嘴的东方明珠隔黄浦江相望，号称是万达旗下七星级酒店。我是第一次参加这种线下的安全会议，从参会体验来说，不论是会议分享的内容还是环境氛围都是相当不错的，从头到尾听下来虽说不可能全盘消化，但在尝试理解的过程中也能得到不少启发。 这篇 MOSEC 参会回忆中没有包含 BaiJiuCon 的部分。所谓 BaiJiuCon，即台下观众自告奋勇上台分享，每喝一小杯茅台可以获得 5 分钟的演讲时间。说来惭愧，当时我的关注点几乎在大屏上方的倒计时，暗中估算分享人还要不要再饮一杯，因此错过一些精彩的内容。如果有下次的话，我一定下不为例…… 在这里感谢提供 MOSEC 门票的华为奇点实验室，感谢 AAA 举办的 ZJUCTF 提供了获取 MOSEC 门票的平台。 Understanding the Apple IO80211Family Subsystem Vol. 2 Speaker: Yu WangBio: The Co-founder and CEO of CyberServal. He loves everything regarding Operating System kernel, from kernel architecture, device driver development, Rootkit&#x2F;Anti-rootkit solutions to vulnerability hunting, exploitation and mitigation. He has previously presented at MOSEC 2020, Black Hat USA 2014, 2020 &amp; 2022, Black Hat Asia 2016 &amp; 2021, Black Hat Europe 2020 and other conferences. 会议的第一个议题演讲者是薮猫科技的王宇老师，也怪我孤陋寡闻、有眼不识泰山，会议前我特地搜了一下，GeekPwn 评委、多次在 BlackHat 发表演讲、前 FireEye 高级研究员等等，title 可以用闪闪发光来形容。 回到议题本身，这次王宇老师分享的内容是 2020 年 Vol.1 的延续。两年前他便在 MOSEC 分享过 IO80211Family 的相关内容，而时过境迁，Apple 针对该子系统也做了重构，王宇老师时隔一年多针对这一重构后的 IO80211Family 又展开了相关研究。 虽然王宇老师分享的条理逻辑很清晰，但假如我声称完全理解了他分享的内容，那一定是谎话甚至是笑话。我可以做到的是列出一些议题中触动我思绪的点，并尝试梳理后记录下来。后面的议题我也会采用类似的方式，整理出一些我的思考。 攻击面的发现往往很重要。记忆中王宇老师提到，Google Project Zero 里有些研究员提出的新的攻击面有时比漏洞本身更具有价值。在我的理解里，用“选择有时大于努力”来比喻这个现象是比较恰当的，一个新的攻击面所带来的或许是数以百计乃至更多的漏洞。 趁手的工具使得漏洞挖掘的过程事半功倍。在王宇老师分享的这个议题当中，这里的“工具”指 Fuzzing 工具与动态调试工具。在研究重构后的 IO80211Family 的过程中，他将之前开源项目 kemon 移植到了 Apple Silicon 平台并基于 lldb 搭建了远程内核调试环境。通过一个 demo 视频，展示了如何结合使用上面提到的两种工具，相信参会的二进制研究人员都能体会到 debugger 在 console 里任你差遣的喜悦与满足。 Do one thing and do it well. 这是 Unix 的哲学，也是 Linux Kernel 的编码规范。王宇老师之所以提到这点，是源于议题中分享的一个他挖洞的亲身经历，漏洞的成因便是在没有遵循上述编码规范： 上面的代码中，if 判断中合并了太多条件，那么 else 中能否将剩下的情况全部当做同一情况处理呢？如果不能，那么这里很可能就会引入漏洞。 漏洞可能会反复出现在同一模块或组件。这是王宇老师的经验之谈，在代码的重构、整合过程中，有可能不知不觉中引入了新的漏洞，甚至会出现栈溢出这样简单却实用的漏洞。此外，在新版本安全补丁发布后，相关审计工作也需要尽早开始，漏洞可能就潜藏在新的 patch 当中。 有一个比较有意思的小插曲，在午饭时也听到了 AAA 的学长们对这个问题的讨论：王宇老师在分享自己的 Fuzzing 工作时提到，作为独立研究员，仅仅用一台 Mac 的计算资源是远不能和 Google 这样企业级的计算资源相提并论的，所以在 Fuzz 时他采用了这样的策略 —— 例如一个函数有 5 个参数，仅选取 3 个进行 Fuzz，这样使得他在相同的时间内使得程序跑到了更“深”的地方，非常神奇。 除了这个议题的分享之外，BaiJiuCon 上也出现了王宇老师的身影，介绍的是之前他在 BlackHat 上演讲的内容。王宇老师这个称呼我觉得名副其实，在我看来，身为 CEO 并且已经拥有了这么多安全的 title，仍能在漏洞挖掘的前线做研究工作，这种热爱是值得所有安全研究人员学习的。 La La Land: Theory and Practice on Large-Scale Static Bug Hunting for Android Systems Speaker: FlankerBio: Qidan He, Senior Director of Shaechi Security Lab. He is the winner of multiple Pwn2Own championships and Pwnie Award Best Privilege Escalation. He is recognized in Google and Samsung’s global top security researcher hall of fame, and has spoken at conferences like Black Hat, DEFCON, RECON, CanSecWest, MOSEC, HITB, PoC, etc. 第二个议题的演讲人是 AAA 的老学长，Flanker —— 何淇丹。如果把王宇老师议题的内容总结为 Fuzzing + 动态调试的话，Flanker 的内容可以总结为污点分析 + 静态分析。 Flanker 主要探讨了 Android Java 静态分析引擎。他提到，目前学术界与工业界的做法是 pointer analysis 结合 call graph build，但仍然存在调用路径的缺失等问题。鉴于此，他引入了安卓平台下使用 IFDS (Interprocedural, Finite, Distributive, Subset Problem) 算法的解决方案。粗略的了解了一下，IFDS 算法用于解决程序静态分析中的过程间数据流分析问题。 最后，Flanker 选取了实战中的一些案例，对三星及小米的部分漏洞进行了较为详细的分析。印象中比较深的是 xiaomi arbitrary download —— 通过条件竞争在下载数据传输的过程中不断尝试 race 覆盖目标下载的应用，从而实现任意应用的下载。 竞争窗口 (race windows) 之前对条件竞争的理解仅仅局限于概念层面，这次会议不少演讲者都提到了 race condition 这一利用方法，也加深了我对它的理解。综合来看，发生条件竞争的核心便是找到合适的竞争窗口，所谓竞争窗口，从代码层面上理解便是竞争对象对应的代码段（可以结合操作系统里的临界区来理解）。例如上面提到的 xiaomi arbitrary download，它是一个 TOCTOU (Time-of-check Time-of-use) Race Condition，这里的竞争窗口便是 check 到 use 这一时间段：程序执行检查资源时通过，但 attacker 在使用这一资源前竞争修改了该资源。 MediAttack - break the boot chain of MediaTek SoC Speaker: Xuewen ZhangBio: Security researcher from Pangu Team. In recent years, her primary interests are low-level security, such as kernel, bootloader, trustzone. 会议的第三个议题，也是上午的最后一个议题，是由盘古实验室的研究员张雪雯带来的。这个议题围绕联发科 (MediaTek, MTK) 芯片的安全启动链展开，主要讲述了相关漏洞的发现与利用。 也是从这个议题开始，我发现前排的 VIP 位置一直没有人入座，本着勤俭节约不浪费的优良美德，我充分利用了 VIP 座位提供的桌子与纸笔，记录下了这个议题的 agenda: Secure Boot Chain First Sight to Attack Attack MTK BootROM Break Boot Chain of MTK MTK Meta Mode Demo 议题的内容在安卓系统层面来说可以说是相当底层了，我对相关知识知之甚少，唯一沾点边的可能就是解锁 Bootloader 并用 Magisk root 过一台 Google Pixel 系列的安卓机。 上图是 MTK 的启动链流程，结合 agenda 来纵观整个议题的内容，可以发现议题是基于漏洞发现并利用这一逻辑进行的。张雪雯首先介绍了上图中的流程，BootROM 在初始时对于研究人员来说是 untouchable 的，因为在从 BootROM 到 Preloader 这一过程中我们无法做任何操作，也没办法提取 BootROM 部分的代码；攻击的切入点是 Preloader，通过 Preloader Download Mode 下的一个越界读写漏洞，使得 dump 出 BootROM 内存与代码执行成为了可能，于是反过来得以对 BootROM 进行深入研究；在针对 BootROM Download Mode 的分析中，印象比较深的是一个任意连续 2 字节写 0 和 2 的漏洞，张雪雯讲到，通过修改边界检查部分的范围绕过白名单，结合另一个漏洞便可以实现任意代码执行；最后展示的 demo 是在 Redmi 上通过前面讲解的漏洞加载自定义操作系统，非常的 amazing. Understanding Mach IPC Speaker: BrightiupBio: Security researcher from Kunlun Lab, focus on kernel security. 非常硬核的一个议题，来自昆仑实验室的 Brightiup 讲的是 Apple 操作系统中 XNU Mach IPC，内容涉及条件竞争与类型混淆。我在纸上记录的内容上画满了问号，例如他讲到的 struct_ipc_port, mk_timer, QoS, turnstile, double fetch 等等，我听的可谓是云里雾里 :( The Tour of Coverage Guided Fuzz for An IoT Micro Kernel System Speakers: Shenrong Liu &amp; Pengju LiuBios: Shenrong Liu is a senior security researcher at Singularity Lab, currently mainly researching mobile and kernel security, and has delivered speeches at BlackHat and other conferences. Pengju Liu is also a security researcher at Singularity Lab, member of Tianshu Dubhe team of Beijing University of Posts and Telecommunications, currently mainly researching kernel security. 这个议题选取的研究对象是不太主流的 FuchisaOS，简单了解了一下， Fuchisa 是 Google 继 Android 与 ChromeOS 后开发的第三款操作系统。不同于前两者，Fuchisa 没有使用 Linux 作为其内核，而是使用了名为 Zircon 的新内核，主要面向的是 IoT 设备。 两位研究员首先介绍了 Zircon 内核中的各种机制，随后分析其攻击面并为其适配了 syzcaller 进行模糊测试，最终挑选了一个 UAF 的漏洞进行展示。 Feat(My First EV)!: Add Support for App Store Speaker: Guanxing WenBio: Security researcher at Pangu in Shanghai, mainly focusing on low-level systems such as trustzone, kernel and peripheral firmware. He is also a fan of pwning smart devices such as TV, speakers, POS and earbuds. He was a speaker at various conferences such as MOSEC，BHEU, Infiltrate and 44CON. 来到了本次会议的最后一个正式议题。 会议进行到这个阶段，按理来说已经较难集中精力去消化演讲者输出的知识了，但不得不承认，闻观行的分享非常吸睛，他分享时语言轻快、生动幽默，给我留下了很深的印象。本来在听完前两个议题后有点自闭，但闻观行讲述故事般的分享，极大地带动了我专注的兴趣与动力。 故事起源于他 2021 年购买的一辆电车。 电车的车载娱乐系统内置的 App 是固定有限的，没有办法安装自己想安装的软件。考虑到有些手机会内置开发者模式，比如连续点击版本号可以打开开发者模式，于是闻观行在车载系统的设置中也做了尝试，发现了一个隐藏的模块，需要输入密码， 这便是他研究这个电车的 motivations: Install App Find secret code 在尝试了 USB、Hotspot 与内置应用隐藏入口无果后，他最后选择了 WebView 作为研究的入口，通过已有的 CVE 一步步进入车载系统，最终摸清这是一个 Nvidia Drive OS 实现的虚拟机架构，并在 demo 中演示了他远程获取 root 权限控制车辆门锁、雨刷器、大灯等设备的视频。 Epilogue行文到此，也接近尾声。 每位嘉宾的议题分享都很惊艳，有的技术分享非常硬核，从代码层面带领观众探究漏洞的成因与 payload 的构造；有的经验分享引人思考，为后人的研究工作提供了宝贵的前人之述；有的过程分享生动有趣，使观众能够带入进去身临其境地体验了研究工作的流程…… 期待下一次的相遇，也期待自己有朝一日可以从台下人的角色转变为台上人。 "},{"title":"HITCON 2022 Reverse Writeup","date":"2022-12-02T08:05:12.000Z","url":"/2022/12/02/HITCON%202022%20Reverse%20Writeup/","tags":[["reverse","/tags/reverse/"],["writeup","/tags/writeup/"]],"categories":[[" ",""]],"content":" Preface Checker problem description analysis recover script solver script Meow Way problem description analysis solver script gocrygo problem description analysis solver script Preface这次比赛是我加入 AAA 之后第一次与 Katzebin 联队打国际赛，最终获得了 rank 7. 今年 HITCON 从北京时间 11 月 25 日晚 10 点开始到 11 月 27 日晚 10 点结束，比赛过程中我主要负责逆向部分的题目。逆向部分在 10 点开赛后首先放出的是 Checker 这道题目，在我分析完 sys 文件中 SMC 的 trick 并把思路放在队伍共享文档之后，Shino 师傅很快便写出了解题脚本，先我一步解出了题目；第二天凌晨 4 点放出了剩下的两道逆向，我是早上看到的题目，由于 Meow Way 比较简单，很快我便解出了；gocrygo 这道题目是针对勒索病毒的分析，关键在于加密算法的识别与 core dump 中 key 的提取，在与 Shino 师傅的合作下，我们很早便拿到了 Tripple DES 加密用到的 24 bytes 密钥，但很长时间都没有明确加密使用的模式，之后又做了许多错误的尝试 … 不过幸运的是在当天晚上，tkmk 师傅查看了这道题目的共享文档，一针见血的指出加密模式为 CTR，于是题目便迎刃而解了。 Checker [198pts]problem descriptionjust a deep and normal checker analysis附件给出了 checker.exe 与 checker_drv.sys 两个文件，其中前者通过 [DeviceIoControl]() 函数向后者对应的驱动程序发送 control code 调用其 check 逻辑，对应驱动程序的设备名为 hitcon_checker 于是主要的逆向工作转向了 sys 即驱动文件，通过 DriverEntry 很容易定位到 sub_140001B50 函数 变量 obj 为对应的驱动对象 (Driver Object)，简单了解后可知 sub_1400011B0 即为其驱动消息处理函数，图中下方容易识别出驱动程序使用了 SMC 这一 trick 来干扰静态分析 进一步分析 sub_1400011B0 函数，该 dispatcher 使用 swich-case 实现了对不同驱动消息的处理，8 个 case 中 7 个调用了相同的函数 sub_1400014D0 ，case 0x222080 对应 exe 中通过 DeviceIoControl 发送的 control code，也就是最终的 check 分析 sub_1400014D0 可知，该函数通过传入的 offset 将对应 data 段字节序列 offset 处的数据用于地址 0x140001B30 的 SMC，在相应修改完成后，调用 0x140001B30 处函数对 flag 对应数据逐字节运算。因此，猜测只需知道上文提到的 7 个 case 的前后调用顺序即可计算得到 flag 满足 check 的条件 起初的想法是爆破这一调用顺序，但随后考虑到每次经过 sub_1400014D0 修改后的相应代码理应是 reasonable 的，即所谓“正常”的字节运算函数，于是结合自动化 patch + 人工核查容易恢复 7 个 case 正确的调用顺序，并根据恢复出的运算逻辑得到 flag recover script solver script Meow Way [193pts]problem descriptionReverse-engineering like the meow way! analysis这个题目主要考察了 windows 程序 x86 与 x64 之间的切换，相关汇编指令如下： 核心是利用 retf 对 CS 寄存器进行修改 此外，题目中 x86 程序对 x64 函数的调用中参数传递还使用到了 cdq 指令，可以理解为该指令实现了 32 位字长的扩展，从而满足调用 64 位函数时对参数字长的要求 算法的逆向部分比较简单，这里不再赘述 solver script gocrygo [248pts]problem descriptionThere are three files in this challenge: gocrygo: A crypto-ransomware. gocrygo_victim_directory: The directory fucked up by this ransomware. core: The ransomware’s core dump when infecting gocrygo_victim_directory. Unfortunately, no decryption service is available :( Your goal is to: Reverse gocrygo Figure out the encryption algorithm it uses Find the encryption key in the core dump Decrypt the entire infected directory. Find the flag in gocrygo_victim_directory. Note: The encryption algorithm is a common cryptographic algorithm (I’m too dumb to implement one myself). In other words, please don’t waste your time figuring out the details of the algorithm. Once you know which algorithm it uses, you can move on to the next phase and try to excavate the encryption key from the core. analysis题目给出了勒索病毒对应的 exe、运行到某时刻的 core dump 与被勒索病毒加密的一个文件夹，我们需要找出文件夹中文件被加密的方式并恢复原始文件 关键在于通过分析 exe 得知对应的加密算法，随后利用 core dump 提取内存中的 key 根据题目名猜测是用 go 编写的，但尝试用工具恢复符号表未果。使用 IDA 分析 exe 并查看字符串，可以看到 crypto/des 相关字符串，推测是使用了 go 中相应模块进行加密操作 在分析过程中，我找到的突破口是 0x2074D3 处对应的字符串，借助 CyberChef 可以识别出来该字符串是 base64 + base85 加密后的结果，交叉引用可以最终定位到 sub_221A61 函数，该函数为遍历文件夹下文件并进行加密的核心函数 分析该函数内部调用到的其他函数，可知： sub_2214EB(char* ptr, uint length): base85 + base64 解密 ptr 处长度 length 的字符串 sub_21406C(char* src, uint src_length, char* dst, uint dst_length): src 与 dst 的 strncmp sub_212FDD(…): go 中 runtime 的 new 操作 sub_21332F(char* err, uint length): panic 并输出 err 处 length 长度的字符串作为错误提示 sub_220965(…): 遍历文件夹并匹配对应文件或文件夹 sub_223E5A(…): 调用加密函数，对文件进行加密 gdb 调试并在该函数设下断点，该函数参数对应的类型是一个结构体，其中 key 在 *(*(a1 + 24) + 8) 处，对应长度 24 bytes，基本可以确定使用的加密算法是 Tripple DES 结合对 sub_222A30 函数的静态分析，并对照  中 3DES 初始化的实现，可在下图位置得知加密使用的模式为 3DES-CTR 在提取密钥的过程中，最初的思路是通过 gdb 的 core 命令加载 core dump，然后查看调用栈定位 dump point，之后另起 gdb 在相同位置下断点正常调试程序，命中断点后查看此时 key 在后者栈上的位置，通过偏移计算前者 key 在栈上的位置。实际操作过程中，由于栈上存有环境变量等其他信息，导致这个偏移并非准确，也就是正常调试的环境与 core dump 中的环境并不一致 幸运的是，调试过程中留意到，key 所在地址的后方留有 /dev/urandom 字符串，将该字符串作为标志在 gdb 中使用 search 命令检索，最终顺利找到 key 所在地址 至此，我们找到了 3DES-CTR 加密所用到的 key，iv 位于被加密文件的前 8 字节，得解 solver script"},{"title":"CVE-2022-0847 Dirty Pipe","date":"2022-03-10T02:07:31.000Z","url":"/2022/03/10/CVE-2022-0847%20Dirty%20Pipe/","tags":[["cve","/tags/cve/"]],"categories":[[" ",""]],"content":" Abstract PoC Analysis Abstract This is the story of CVE-2022-0847, a vulnerability in the Linux kernel since 5.8 which allows overwriting data in arbitrary read-only files. This leads to privilege escalation because unprivileged processes can inject code into root processes.It is similar to CVE-2016-5195 “Dirty Cow” but is easier to exploit.The vulnerability was fixed in Linux 5.16.11, 5.15.25 and 5.10.102. 此 Linux 内核漏洞经 CM4all 团队的 Max Kellermann &lt; max.kellermann@ionos.com &gt;披露，目前已在新版本的 Linux 内核中被修复。 在 Max Kellermann 给出的 PoC 中，漏洞的成因是 copy_page_to_iter_pipe() 函数在调用时并未对相应 pipe_buffer 结构体中的 flags 进行初始化，导致 PIPE_BUF_FLAG_CAN_MERGE 仍维持置位状态，进一步导致了 splice() 系统调用将指向只读文件的页指针拷贝（zero-copy）至管道后，对管道的写入不会申请新的页，而是在当前指针指向的页中继续写入，从而造成了对只读文件的越权写入。 PoC 复现过程： AnalysisMax Kellermann 在 blog 中讲述了他发现此内核漏洞的过程。 起初，客户向他反映从日志服务器上下载下来的 gzip 日志解压遇到了 CRC 错误，他手动修复了 CRC 校验后便不以为意。 随后，越来越多类似的错误出现，他在分析后发现，总是每个月最后打包的日期对应的 gzip 日志出现 CRC 校验错误，且文件总是以 50 4b 01 02 1e 03 14 00 结束，这 8 字节覆盖了原先正确的结尾。 Max Kellermann 的日志服务器使用了 splice() 系统调用来将每日的 gzip 日志“拼接”起来，并在整个“日志串”的头尾分别添加 ZIP 压缩文件对应的头尾，以此来减少在解压后重新压缩的开销。没错，50 4b 01 02 1e 03 14 00 正是 ZIP 压缩文件尾部对应的 Central directory file header 前 8 字节。 要明白为什么出现这种错误，首先要了解 splice() 做了什么： 简而言之，splice() 系统调用顾名思义是把 fd_in 对应 off_in 偏移处 len 长度的内容“拼接”到 fd_out 对应 off_out 偏移处（规定 fd_in 与 fd_out 中至少有一个为管道描述符），需要注意的是这一过程中使用了“零拷贝（zero-copy）”机制，即拷贝过程中，无需内核空间与用户空间之间的拷贝操作，直接将指向页的指针进行拷贝。 上面给出了管道（pipe）相关的结构体与两个重要的宏定义。 struct pipe_inode_info 定义了 Linux 内核中的管道，管道实际上是由 ring_size 的 struct pipe_buffer 首尾相连构成的环形结构，其最大容量为 PIPE_DEF_BUFFERS。管道作为经典的生产者消费者模型实例，其成员 head 指向了生产者(production)，tail 指向了消费者(consumption)。 struct pipe_buffer 定义了管道中的单个缓冲区，每个缓冲区都指向一个 struct page 即页，页的大小可通过 Linux 命令 getconf PAGESIZE 查看，通常为 4096 即 4KB，成员 flags 为该缓冲区对应的标志位。 我们知道，对管道进行读（read）或写（write）时，read() &#x2F; write() 系统调用实际上会调用 pipe_read() &#x2F; pipe_write() ，随后调用 copy_page_to_iter_pipe() &#x2F; copy_page_from_iter_pipe() 。 回头分析 PoC，prepare_pipe() 函数首先将管道填满以此将管道中每个 pipe_buffer 对应的 PIPE_BUF_FLAG_CAN_MERGE 标志位都处于置位状态。分析 pipe_write() 函数源码可知，当前写入的 pipe_buffer 非空时，系统都会尝试将新写入的内容与其合并（插入空 pipe_buffer 时 PIPE_BUF_FLAG_CAN_MERGE 标志位默认置位），而调用 pipe_read() 时，由于调用的 copy_page_to_iter_pipe() 函数并未对 pipe_buffer 中的 flags 进行初始化，导致 splice() 后对 pipe_buffer 的写入合并到了只读文件对应的页中。"},{"title":"search","date":"2022-12-02T11:40:39.000Z","url":"/search/index.html","categories":[[" ",""]]},{"title":"About","date":"2022-12-02T11:41:24.000Z","url":"/about/index.html","categories":[[" ",""]],"content":"Who Am I name: arcovegle email: &#x61;&#114;&#99;&#111;&#118;&#x65;&#103;&#108;&#101;&#64;&#49;&#54;&#x33;&#46;&#x63;&#111;&#x6d; undergraduate: Northeastern University postgraduate: ZheJiang University (reading) Team N3X AAA (active) Honor First prize of National College Student Information Security Contest (CISCN) @ N3X SECCON CTF 2022 Finalist @ AAA "}]