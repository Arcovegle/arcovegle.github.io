[{"title":"HITCON 2022 Reverse Writeup","date":"2022-12-02T08:05:12.000Z","url":"/2022/12/02/HITCON%202022%20Reverse%20Writeup/","tags":[["reverse","/tags/reverse/"],["writeup","/tags/writeup/"]],"categories":[[" ",""]],"content":" preface Checker problem description analysis recover script solver script Meow Way problem description analysis solver script gocrygo problem description analysis solver script preface这次比赛是我加入 AAA 之后第一次与 Katzebin 联队打国际赛，最终获得了 rank 7. 今年 HITCON 从北京时间 11 月 25 日晚 10 点开始到 11 月 27 日晚 10 点结束，比赛过程中我主要负责逆向部分的题目。逆向部分在 10 点开赛后首先放出的是 Checker 这道题目，在我分析完 sys 文件中 SMC 的 trick 并把思路放在队伍共享文档之后，Shino 师傅很快便写出了解题脚本，先我一步解出了题目；第二天凌晨 4 点放出了剩下的两道逆向，我是早上看到的题目，由于 Meow Way 比较简单，很快我便解出了；gocrygo 这道题目是针对勒索病毒的分析，关键在于加密算法的识别与 core dump 中 key 的提取，在与 Shino 师傅的合作下，我们很早便拿到了 Tripple DES 加密用到的 24 bytes 密钥，但很长时间都没有明确加密使用的模式，之后又做了许多错误的尝试 … 不过幸运的是在当天晚上，tkmk 师傅查看了这道题目的共享文档，一针见血的指出加密模式为 CTR，于是题目便迎刃而解了。 Checker [198pts]problem descriptionjust a deep and normal checker analysis附件给出了 checker.exe 与 checker_drv.sys 两个文件，其中前者通过 [DeviceIoControl]() 函数向后者对应的驱动程序发送 control code 调用其 check 逻辑，对应驱动程序的设备名为 hitcon_checker 于是主要的逆向工作转向了 sys 即驱动文件，通过 DriverEntry 很容易定位到 sub_140001B50 函数 变量 obj 为对应的驱动对象 (Driver Object)，简单了解后可知 sub_1400011B0 即为其驱动消息处理函数，图中下方容易识别出驱动程序使用了 SMC 这一 trick 来干扰静态分析 进一步分析 sub_1400011B0 函数，该 dispatcher 使用 swich-case 实现了对不同驱动消息的处理，8 个 case 中 7 个调用了相同的函数 sub_1400014D0 ，case 0x222080 对应 exe 中通过 DeviceIoControl 发送的 control code，也就是最终的 check 分析 sub_1400014D0 可知，该函数通过传入的 offset 将对应 data 段字节序列 offset 处的数据用于地址 0x140001B30 的 SMC，在相应修改完成后，调用 0x140001B30 处函数对 flag 对应数据逐字节运算。因此，猜测只需知道上文提到的 7 个 case 的前后调用顺序即可计算得到 flag 满足 check 的条件 起初的想法是爆破这一调用顺序，但随后考虑到每次经过 sub_1400014D0 修改后的相应代码理应是 reasonable 的，即所谓“正常”的字节运算函数，于是结合自动化 patch + 人工核查容易恢复 7 个 case 正确的调用顺序，并根据恢复出的运算逻辑得到 flag recover script solver script Meow Way [193pts]problem descriptionReverse-engineering like the meow way! analysis这个题目主要考察了 windows 程序 x86 与 x64 之间的切换，相关汇编指令如下： 核心是利用 retf 对 CS 寄存器进行修改 此外，题目中 x86 程序对 x64 函数的调用中参数传递还使用到了 cdq 指令，可以理解为该指令实现了 32 位字长的扩展，从而满足调用 64 位函数时对参数字长的要求 算法的逆向部分比较简单，这里不再赘述 solver script gocrygo [248pts]problem descriptionThere are three files in this challenge: gocrygo: A crypto-ransomware. gocrygo_victim_directory: The directory fucked up by this ransomware. core: The ransomware’s core dump when infecting gocrygo_victim_directory. Unfortunately, no decryption service is available :( Your goal is to: Reverse gocrygo Figure out the encryption algorithm it uses Find the encryption key in the core dump Decrypt the entire infected directory. Find the flag in gocrygo_victim_directory. Note: The encryption algorithm is a common cryptographic algorithm (I’m too dumb to implement one myself). In other words, please don’t waste your time figuring out the details of the algorithm. Once you know which algorithm it uses, you can move on to the next phase and try to excavate the encryption key from the core. analysis题目给出了勒索病毒对应的 exe、运行到某时刻的 core dump 与被勒索病毒加密的一个文件夹，我们需要找出文件夹中文件被加密的方式并恢复原始文件 关键在于通过分析 exe 得知对应的加密算法，随后利用 core dump 提取内存中的 key 根据题目名猜测是用 go 编写的，但尝试用工具恢复符号表未果。使用 IDA 分析 exe 并查看字符串，可以看到 crypto/des 相关字符串，推测是使用了 go 中相应模块进行加密操作 在分析过程中，我找到的突破口是 0x2074D3 处对应的字符串，借助 CyberChef 可以识别出来该字符串是 base64 + base85 加密后的结果，交叉引用可以最终定位到 sub_221A61 函数，该函数为遍历文件夹下文件并进行加密的核心函数 分析该函数内部调用到的其他函数，可知： sub_2214EB(char* ptr, uint length): base85 + base64 解密 ptr 处长度 length 的字符串 sub_21406C(char* src, uint src_length, char* dst, uint dst_length): src 与 dst 的 strncmp sub_212FDD(…): go 中 runtime 的 new 操作 sub_21332F(char* err, uint length): panic 并输出 err 处 length 长度的字符串作为错误提示 sub_220965(…): 遍历文件夹并匹配对应文件或文件夹 sub_223E5A(…): 调用加密函数，对文件进行加密 gdb 调试并在该函数设下断点，该函数参数对应的类型是一个结构体，其中 key 在 *(*(a1 + 24) + 8) 处，对应长度 24 bytes，基本可以确定使用的加密算法是 Tripple DES 结合对 sub_222A30 函数的静态分析，并对照  中 3DES 初始化的实现，可在下图位置得知加密使用的模式为 3DES-CTR 在提取密钥的过程中，最初的思路是通过 gdb 的 core 命令加载 core dump，然后查看调用栈定位 dump point，之后另起 gdb 在相同位置下断点正常调试程序，命中断点后查看此时 key 在后者栈上的位置，通过偏移计算前者 key 在栈上的位置。实际操作过程中，由于栈上存有环境变量等其他信息，导致这个偏移并非准确，也就是正常调试的环境与 core dump 中的环境并不一致 幸运的是，调试过程中留意到，key 所在地址的后方留有 /dev/urandom 字符串，将该字符串作为标志在 gdb 中使用 search 命令检索，最终顺利找到 key 所在地址 至此，我们找到了 3DES-CTR 加密所用到的 key，iv 位于被加密文件的前 8 字节，得解 solver script"},{"title":"CVE-2022-0847 Dirty Pipe","date":"2022-03-10T02:07:31.000Z","url":"/2022/03/10/CVE-2022-0847%20Dirty%20Pipe/","tags":[["cve","/tags/cve/"]],"categories":[[" ",""]],"content":" Abstract PoC Analysis Abstract This is the story of CVE-2022-0847, a vulnerability in the Linux kernel since 5.8 which allows overwriting data in arbitrary read-only files. This leads to privilege escalation because unprivileged processes can inject code into root processes.It is similar to CVE-2016-5195 “Dirty Cow” but is easier to exploit.The vulnerability was fixed in Linux 5.16.11, 5.15.25 and 5.10.102. 此 Linux 内核漏洞经 CM4all 团队的 Max Kellermann &lt; max.kellermann@ionos.com &gt;披露，目前已在新版本的 Linux 内核中被修复。 在 Max Kellermann 给出的 PoC 中，漏洞的成因是 copy_page_to_iter_pipe() 函数在调用时并未对相应 pipe_buffer 结构体中的 flags 进行初始化，导致 PIPE_BUF_FLAG_CAN_MERGE 仍维持置位状态，进一步导致了 splice() 系统调用将指向只读文件的页指针拷贝（zero-copy）至管道后，对管道的写入不会申请新的页，而是在当前指针指向的页中继续写入，从而造成了对只读文件的越权写入。 PoC 复现过程： AnalysisMax Kellermann 在 blog 中讲述了他发现此内核漏洞的过程。 起初，客户向他反映从日志服务器上下载下来的 gzip 日志解压遇到了 CRC 错误，他手动修复了 CRC 校验后便不以为意。 随后，越来越多类似的错误出现，他在分析后发现，总是每个月最后打包的日期对应的 gzip 日志出现 CRC 校验错误，且文件总是以 50 4b 01 02 1e 03 14 00 结束，这 8 字节覆盖了原先正确的结尾。 Max Kellermann 的日志服务器使用了 splice() 系统调用来将每日的 gzip 日志“拼接”起来，并在整个“日志串”的头尾分别添加 ZIP 压缩文件对应的头尾，以此来减少在解压后重新压缩的开销。没错，50 4b 01 02 1e 03 14 00 正是 ZIP 压缩文件尾部对应的 Central directory file header 前 8 字节。 要明白为什么出现这种错误，首先要了解 splice() 做了什么： 简而言之，splice() 系统调用顾名思义是把 fd_in 对应 off_in 偏移处 len 长度的内容“拼接”到 fd_out 对应 off_out 偏移处（规定 fd_in 与 fd_out 中至少有一个为管道描述符），需要注意的是这一过程中使用了“零拷贝（zero-copy）”机制，即拷贝过程中，无需内核空间与用户空间之间的拷贝操作，直接将指向页的指针进行拷贝。 上面给出了管道（pipe）相关的结构体与两个重要的宏定义。 struct pipe_inode_info 定义了 Linux 内核中的管道，管道实际上是由 ring_size 的 struct pipe_buffer 首尾相连构成的环形结构，其最大容量为 PIPE_DEF_BUFFERS。管道作为经典的生产者消费者模型实例，其成员 head 指向了生产者(production)，tail 指向了消费者(consumption)。 struct pipe_buffer 定义了管道中的单个缓冲区，每个缓冲区都指向一个 struct page 即页，页的大小可通过 Linux 命令 getconf PAGESIZE 查看，通常为 4096 即 4KB，成员 flags 为该缓冲区对应的标志位。 我们知道，对管道进行读（read）或写（write）时，read() &#x2F; write() 系统调用实际上会调用 pipe_read() &#x2F; pipe_write() ，随后调用 copy_page_to_iter_pipe() &#x2F; copy_page_from_iter_pipe() 。 回头分析 PoC，prepare_pipe() 函数首先将管道填满以此将管道中每个 pipe_buffer 对应的 PIPE_BUF_FLAG_CAN_MERGE 标志位都处于置位状态。分析 pipe_write() 函数源码可知，当前写入的 pipe_buffer 非空时，系统都会尝试将新写入的内容与其合并（插入空 pipe_buffer 时 PIPE_BUF_FLAG_CAN_MERGE 标志位默认置位），而调用 pipe_read() 时，由于调用的 copy_page_to_iter_pipe() 函数并未对 pipe_buffer 中的 flags 进行初始化，导致 splice() 后对 pipe_buffer 的写入合并到了只读文件对应的页中。"},{"title":"About","date":"2022-12-02T11:41:24.000Z","url":"/about/index.html","categories":[[" ",""]],"content":"Who Am I name: arcovegle email: &#97;&#x72;&#x63;&#111;&#x76;&#101;&#x67;&#108;&#x65;&#x40;&#x31;&#54;&#51;&#x2e;&#x63;&#x6f;&#x6d; undergraduate: Northeastern University postgraduate: ZheJiang University (reading) Team N3X AAA (active) Honor First prize of National College Student Information Security Contest (CISCN) @ N3X "},{"title":"search","date":"2022-12-02T11:40:39.000Z","url":"/search/index.html","categories":[[" ",""]]}]